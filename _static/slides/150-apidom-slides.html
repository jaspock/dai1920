<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="author" content="Desarrollo de Aplicaciones en Internet">
  <title>La API para JavaScript del navegador</title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
  <link rel="stylesheet" href="reveal.js/css/reset.css">
  <link rel="stylesheet" href="reveal.js/css/reveal.css">
  <style>
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <link rel="stylesheet" href="reveal.js/css/theme/simple.css" id="theme">
  <!-- Printing and PDF exports -->
  <script>
    var link = document.createElement( 'link' );
    link.rel = 'stylesheet';
    link.type = 'text/css';
    link.href = window.location.search.match( /print-pdf/gi ) ? 'reveal.js/css/print/pdf.css' : 'reveal.js/css/print/paper.css';
    document.getElementsByTagName( 'head' )[0].appendChild( link );
  </script>
  <!--[if lt IE 9]>
  <script src="reveal.js/lib/js/html5shiv.js"></script>
  <![endif]-->
</head>
<body>
  <div class="reveal">
    <div class="slides">

<section id="title-slide">
  <h1 class="title">La API para JavaScript del navegador</h1>
  <p class="author">Desarrollo de Aplicaciones en Internet</p>
</section>

<section id="la-api-para-javascript-del-navegador-web-api" class="slide level2">
<h2>La API para JavaScript del navegador (Web API)</h2>
<p>Desarrollo de Aplicaciones en Internet</p>
<p>Fuente: <a href="https://www.kirupa.com/html5/learn_javascript.htm">JavaScript</a></p>
<p>Fuente: <a href="https://developer.mozilla.org/es/docs/Web/API">Web API reference</a></p>
</section>
<section id="cosas-que-podemos-hacer-con-las-apis-web" class="slide level2">
<h2>Cosas que podemos hacer con las <em>APIs web</em>:</h2>
<ul>
<li><em>Escuchar</em> eventos (por ejemplo, un clic del ratón o el borrado de un elemento del DOM) y ejecutar código en respuesta a ellos.</li>
<li>Modificar <em>en vivo</em> el HTML y el CSS de un documento.</li>
<li>Intercambiar datos con un servidor (lo veremos en otro tema).</li>
<li>Retardar la ejecución de un código hasta dentro de un tiempo (<em>setTimeout</em>).</li>
<li>Almacenar información en una base de datos del navegador.</li>
</ul>
</section>
<section id="cosas-que-podemos-hacer-con-las-apis-web-1" class="slide level2">
<h2>Cosas que podemos hacer con las <em>APIs web</em>:</h2>
<ul>
<li>Interactuar con webcams, geolocalización, micrófono, etc.</li>
<li>Realizar animaciones (por ejemplo, mediante <em>canvas</em> o <em>SVG</em>).</li>
<li>Ejecutar algoritmos.</li>
<li>…</li>
</ul>
</section>
<section id="el-dom" class="slide level2">
<h2>El DOM</h2>
<ul>
<li>Los nodos representan <strong>elementos</strong>, atributos, contenido textual, comentarios, etc.</li>
<li>Jerarquía de tipos para los elementos: <em>Node</em> &lt;- <em>Element</em> &lt;- {<em>HTMLElement</em>, <em>SVGElement</em>}</li>
</ul>
</section>
<section id="el-dom-1" class="slide level2">
<h2>El DOM</h2>
<p><img data-src="data/kirupa/DOM_js_72.png" /></p>
<p><a href="https://www.kirupa.com/html5/">Fuente</a></p>
</section>
<section id="objetos-window-y-document" class="slide level2">
<h2>Objetos window y document</h2>
<ul>
<li>El objeto global <em>window</em> (tipo <em>Window</em>) representa la ventana que contiene un documento DOM; podemos acceder a numerosas propiedades como <em>window.innerWidth</em>.</li>
<li>El objeto global <em>document</em> (tipo <em>Document</em>) es la puerta de entrada al árbol DOM; es el objeto que vamos a usar más a menudo, por ejemplo, a través de funciones como <em>querySelector</em>.</li>
<li>El objeto global <em>document.body</em> permite acceder al cuerpo del documento.</li>
</ul>
</section>
<section id="acceso-a-elementos-mediante-selectores-css" class="slide level2">
<h2>Acceso a elementos mediante selectores CSS</h2>
<ul>
<li><em>querySelector</em> devuelve un elemento (tipo <em>Element</em>); se devuelve el primero si más de uno satisface el criterio del selector</li>
<li><em>querySelectorAll</em> devuelve una lista <em>no viva</em> de elementos</li>
</ul>
<pre><code>var el = document.querySelector(&quot;.miClase&quot;);</code></pre>
<pre><code>var images = document.querySelectorAll(&quot;img.pictures, img.charts&quot;);

for (var i = 0; i &lt; images.length; i++) {
    console.log(images[i].getAttribute(&quot;src&quot;));
}</code></pre>
</section>
<section id="antes-de-que-existiera-queryselector" class="slide level2">
<h2>Antes de que existiera <em>querySelector</em></h2>
<ul>
<li>Estos dos fragmentos de código son equivalentes pero la primera forma (estandarizada más recientemente) es mucho más compacta:</li>
</ul>
<pre><code>document.querySelector(&quot;#settingsForm &gt; table &gt; tbody &gt; tr:nth-child(2) &gt; td:first-child&quot;)
        .innerHTML+= &quot;&lt;p&gt;Tim Berners-Lee&lt;/p&gt;&quot;;</code></pre>
<pre><code>document.getElementById(&quot;settingsForm&quot;).getElementsByTagName(&quot;table&quot;)[0
        .getElementsByTagName(&quot;tbody&quot;)[0].getElementsByTagName(&quot;tr&quot;)[1]
        .getElementsByTagName(&quot;td&quot;)[0].innerHTML+= &quot;&lt;p&gt;Tim Berners-Lee&lt;/p&gt;&quot;;</code></pre>
</section>
<section id="consulta-y-modificación-del-dom" class="slide level2">
<h2>Consulta y modificación del DOM</h2>
<ul>
<li>Modificación del contenido textual de un elemento:</li>
</ul>
<pre><code>var title = document.querySelector(&quot;#intro&quot;);
title.textContent = &quot;Ulises&quot;;</code></pre>
</section>
<section id="consulta-y-modificación-de-atributos" class="slide level2">
<h2>Consulta y modificación de atributos</h2>
<pre><code>var title = document.querySelector(&quot;#picture&quot;);
title.setAttribute(&quot;src&quot;, &quot;http://www.example.com&quot;);
var t = title.getAttribute(&quot;alt&quot;);
var i = title.id;             // para id y class no es necesario usar los métodos anteriores
title.className = &quot;bar foo&quot;;  // el id y la clase se exponen como atributos de un elemento</code></pre>
</section>
<section id="consulta-y-modificación-de-clases" class="slide level2">
<h2>Consulta y modificación de clases</h2>
<ul>
<li>Una manera mejor que <em>className</em> de gestionar las clases de un elemento.</li>
</ul>
<pre><code>var divElement = document.querySelector(&quot;#myDiv&quot;);
divElement.classList.add(&quot;bar&quot;);
divElement.classList.remove(&quot;foo&quot;);
divElement.classList.toggle(&quot;foo&quot;);

if (divElement.classList.contains(&quot;bar&quot;)) {
    ....
}

divElement.className = &quot;&quot;;  // borra todas las clases</code></pre>
</section>
<section id="consulta-y-modificación-del-atributo-style-de-un-elemento" class="slide level2">
<h2>Consulta y modificación del atributo <em>style</em> de un elemento</h2>
<pre><code>&lt;!doctype html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;simple style example&lt;/title&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
  function alterStyle(elem) {
    elem.style.backgroundColor = &quot;green&quot;;   // los guiones se eliminan en el nombre del atributo
  }
  function resetStyle(elemId) {
    elem = document.getElementById(elemId);
    elem.style.backgroundColor = &#39;white&#39;;
  }
&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;p id=&quot;p1&quot; onclick=&quot;alterStyle(this);&quot;&gt;Click here to change background color.&lt;/p&gt;
&lt;button onclick=&quot;resetStyle(&#39;p1&#39;);&quot;&gt;Reset background color&lt;/button&gt;
&lt;!-- Es recomendable añadir los eventos con addEventListener y no con onclick --&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
</section>
<section id="consulta-y-modificación-de-estilos" class="slide level2">
<h2>Consulta y modificación de estilos</h2>
<ul>
<li><em>style</em> solo devuelve propiedades asignadas en línea al elemento (con el atributo <em>style</em>) o mediante <em>element.style.propiedad</em>.</li>
<li>Para modificar los estilos de múltiples elementos, se puede inyectar desde JavaScript elementos de tipo <em>style</em> o añadir reglas a una hoja existente.</li>
</ul>
<pre><code>var e = document.createElement(&quot;style&quot;);
e.innerHTML= &quot;p {color: red;}&quot;
document.head.appendChild(e);</code></pre>
<pre><code>var e= document.querySelector(&#39;link[href=&quot;normal.css&quot;]&#39;&#39;)
e.sheet.insertRule(&quot;p { background-color: blue}&quot;);  //otra manera</code></pre>
</section>
<section id="recorrer-el-dom" class="slide level2">
<h2>Recorrer el DOM</h2>
<p><img data-src="data/kirupa/parents_siblings_children_72.png" /></p>
<p><a href="https://www.kirupa.com/html5/">Fuente</a></p>
</section>
<section id="recorrer-el-dom-1" class="slide level2">
<h2>Recorrer el DOM</h2>
<p><img data-src="data/kirupa/all_the_family_72.png" /></p>
<p><a href="https://www.kirupa.com/html5/">Fuente</a></p>
</section>
<section id="recorrer-el-dom-2" class="slide level2">
<h2>Recorrer el DOM</h2>
<p><img data-src="data/kirupa/all_the_family_children_72.png" /></p>
<p><a href="https://www.kirupa.com/html5/">Fuente</a></p>
</section>
<section id="recorrer-el-dom-3" class="slide level2">
<h2>Recorrer el DOM</h2>
<pre><code>var bodyElement = document.body;

if (bodyElement.firstChild) {
    ...
}</code></pre>
<pre><code>var bodyElement = document.body;

for (var i = 0; i &lt; bodyElement.children.length; i++) {
    var childElement = bodyElement.children[i];
    console.log(childElement.tagName);
}</code></pre>
<pre><code>function theDOMElementWalker(node) {
  if (node.nodeType == Node.ELEMENT_NODE) {
    //console.log(node.tagName);
    node = node.firstChild;
    while (node) {
      theDOMElementWalker(node);
      node = node.nextSibling;
    }
  }
}</code></pre>
</section>
<section id="creación-de-elementos-en-el-dom-más-recomendable-que-usar-innerhtml" class="slide level2">
<h2>Creación de elementos en el DOM (más recomendable que usar innerHTML)</h2>
<ol type="1">
<li>Crear el elemento con <em>document.createElement</em>.</li>
<li>Obtener una referencia al nodo que hará de padre.</li>
<li>Insertar el nuevo nodo con <em>appendChild</em>.</li>
</ol>
<pre><code>&lt;body&gt;
  &lt;h1 id=&quot;theTitle&quot; class=&quot;highlight summer&quot;&gt;What&#39;s happening?&lt;/h1&gt;

  &lt;script&gt;
    var newElement = document.createElement(&quot;p&quot;);
    newElement.textContent = &quot;I exist entirely in your imagination.&quot;;
    document.body.appendChild(newElement);
  &lt;/script&gt;
&lt;/body&gt;</code></pre>
</section>
<section id="innerhtml-y-textcontent" class="slide level2">
<h2>innerHTML y textContent</h2>
<ul>
<li><em>innerHTML</em> analiza (<em>parsing</em>) el contenido como HTML y tarda más.</li>
<li><em>textContent</em> interpreta el contenido como texto plano, es más rápido y previene ataques XSS (<em>cross-site scripting</em>)</li>
</ul>
</section>
<section id="creación-de-elementos-en-el-dom" class="slide level2">
<h2>Creación de elementos en el DOM</h2>
<ul>
<li><em>appendChild</em> siempre añade el nuevo elemento como último hijo del padre.</li>
<li>Para insertarlo en otra posición hay que usar <em>insertBefore</em>.</li>
</ul>
<pre><code>&lt;body&gt;
  &lt;h1 id=&quot;theTitle&quot; class=&quot;highlight summer&quot;&gt;What&#39;s happening?&lt;/h1&gt;
  &lt;script&gt;
    var newElement = document.createElement(&quot;p&quot;);
    newElement.textContent = &quot;I exist entirely in your imagination.&quot;;
    var scriptElement = document.querySelector(&quot;script&quot;);
    document.body.insertBefore(newElement, scriptElement);

    document.body.removeChild(newElement);  // borrado del elemento
    // newElement.parentNode.removeChild(newElement);  // equivalente para cuando no tenemos un objeto apuntando al padre
  &lt;/script&gt;
&lt;/body&gt;</code></pre>
</section>
<section id="gestión-de-eventos" class="slide level2">
<h2>Gestión de eventos</h2>
<ul>
<li>Eventos típicos son <em>click</em>, <em>mouseover</em>, <em>DOMContentLoaded</em> (cuando el DOM se ha cargado), <em>load</em> (cuando todo el documento se ha cargado), <em>keydown</em>, <em>keyup</em>…</li>
</ul>
<pre><code>&lt;!doctype html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;Click Anywhere!&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;script&gt;
    document.addEventListener(&quot;click&quot;, changeColor, false);

    function changeColor() {
      document.body.style.backgroundColor = &quot;#FFC926&quot;;
    }
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
</section>
<section id="gestión-de-eventos-1" class="slide level2">
<h2>Gestión de eventos</h2>
<ul>
<li>El manejador de eventos es invocado con un parámetro de tipo evento.</li>
<li><em>e.currentTarget</em> es el elemento al que se asoció el manejador, mientras que <em>e.target</em> es el elemento sobre el que ha ocurrido el evento.</li>
</ul>
<pre><code>function hide(e){
  e.currentTarget.style.visibility = &quot;hidden&quot;;
}

var ps = document.getElementsByTagName(&#39;p&#39;);

for(var i = 0; i &lt; ps.length; i++){
  ps[i].addEventListener(&#39;click&#39;, hide, false);
}

// click around and make paragraphs disappear</code></pre>
</section>
<section id="captura-y-burbujeo-de-eventos" class="slide level2">
<h2>Captura y burbujeo de eventos</h2>
<p><img data-src="data/kirupa/bubble_phase_72.png" /></p>
<p><a href="https://www.kirupa.com/html5/">Fuente</a></p>
</section>
<section id="captura-y-burbujeo-de-eventos-1" class="slide level2">
<h2>Captura y burbujeo de eventos</h2>
<ul>
<li>Los eventos comienzan por la raíz del árbol y se van propagando hacia abajo hasta llegar al elemento en que se produjo.</li>
<li>En una segunda fase <em>burbujean</em> (<em>to bubble</em>) hacia arriba.</li>
<li>En cada paso, se invoca a los manejadores de eventos que hayan sido definidos.</li>
<li>El tercer parámetro de <em>addEventListener</em> es un booleano que define si el manejador de evento es para la fase de captura o la de <em>bubbling</em>.</li>
<li><em>e.stopPropagation()</em> detiene el proceso en el manejador actual.</li>
</ul>
</section>
<section id="captura-y-burbujeo-de-eventos-2" class="slide level2">
<h2>Captura y burbujeo de eventos</h2>
<ul>
<li>Comprueba la salida de la siguiente aplicación web.</li>
</ul>
<pre><code>&lt;!doctype html&gt;
&lt;html&gt;
&lt;body id=&quot;theBody&quot; class=&quot;item&quot;&gt;
    &lt;div id=&quot;one_a&quot; class=&quot;item&quot;&gt;
        &lt;div id=&quot;two&quot; class=&quot;item&quot;&gt;
            &lt;div id=&quot;three_a&quot; class=&quot;item&quot;&gt;
                &lt;button id=&quot;buttonOne&quot; class=&quot;item&quot;&gt;one&lt;/button&gt;
            &lt;/div&gt;
            &lt;div id=&quot;three_b&quot; class=&quot;item&quot;&gt;
                &lt;button id=&quot;buttonTwo&quot; class=&quot;item&quot;&gt;two&lt;/button&gt;
                &lt;button id=&quot;buttonThree&quot; class=&quot;item&quot;&gt;three&lt;/button&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;div id=&quot;one_b&quot; class=&quot;item&quot;&gt;

    &lt;/div&gt;

    &lt;script&gt;
        var items = document.querySelectorAll(&quot;.item&quot;);

        for (var i = 0; i &lt; items.length; i++) {
            var el = items[i];

            //capturing phase
            el.addEventListener(&quot;click&quot;, doSomething, true);

            //bubbling phase
            el.addEventListener(&quot;click&quot;, doSomething, false);
        }

        function doSomething(e) {
            console.log(e.currentTarget.id);
        }
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
</section>
<section id="el-bucle-de-eventos" class="slide level2">
<h2>El bucle de eventos</h2>
<ul>
<li>La ejecución del código de un programa en JavaScript se produce en un único hilo (normalmente, uno por cada pestaña del navegador).</li>
<li>Este hilo se puede bloquear (de manera que la aplicación del navegador deja de responder) si se ejecuta código muy largo o un bucle infinito.</li>
<li>Muchas funciones de la <em>API web</em> que tienen que ver con entrada/salida son <em>no bloqueantes</em> / <em>asíncronas</em> y se ejecutan en otro hilo.</li>
</ul>
<pre><code>function timeout() {
  timeoutID = window.setTimeout(f, 2000);
}

// función de callback
function f() {...}</code></pre>
</section>
<section id="el-bucle-de-eventos-1" class="slide level2">
<h2>El bucle de eventos</h2>
<ul>
<li>El hilo principal no se bloquea mientras esas funciones del API web se ejecutan.</li>
<li>Cuando una función asíncrona de la <em>API web</em> acaba, encola la llamada a una función de <em>callback</em> (como las usadas en los manejadores de eventos) definida en el programa principal .</li>
</ul>
</section>
<section id="el-bucle-de-eventos-2" class="slide level2">
<h2>El bucle de eventos</h2>
<ul>
<li>El bucle de eventos atiende y ejecuta las funciones almacenadas en la cola de funciones <em>callback</em>.</li>
<li>El motor de JavaScript no procesa el bucle de eventos hasta que el código del <em>callback</em> actual termina.</li>
<li>Cada hilo de JavaScript utiliza una pila y un <em>heap</em> de forma similar a otros lenguajes de programación.</li>
<li>En general, el bucle de eventos no llama a ninguna función de <em>callback</em> hasta que la pila esté vacía.</li>
<li>Herramienta para visualizar todo lo anterior (<a href="http://latentflip.com/loupe/?code=ZnVuY3Rpb24gcHJpbnRIZWxsbygpIHsNCiAgICBjb25zb2xlLmxvZygnSGVsbG8gZnJvbSBiYXonKTsNCn0NCg0KZnVuY3Rpb24gYmF6KCkgew0KICAgIHNldFRpbWVvdXQocHJpbnRIZWxsbywgMzAwMCk7DQp9DQoNCmZ1bmN0aW9uIGJhcigpIHsNCiAgICBiYXooKTsNCn0NCg0KZnVuY3Rpb24gZm9vKCkgew0KICAgIGJhcigpOw0KfQ0KDQpmb28oKTs%3D!!!PGJ1dHRvbj5DbGljayBtZSE8L2J1dHRvbj4%3D">un ejemplo</a>, <a href="http://latentflip.com/loupe/">otro</a>).</li>
</ul>
</section>
<section id="qué-ocurre-cuando-se-carga-una-página" class="slide level2">
<h2>Qué ocurre cuando se carga una página</h2>
<p><img data-src="data/kirupa/summary_72.png" /></p>
<p><a href="https://www.kirupa.com/html5/">Fuente</a></p>
</section>
<section id="dónde-colocar-las-referencias-a-ficheros-externos-de-javascript" class="slide level2">
<h2>Dónde colocar las referencias a ficheros externos de JavaScript</h2>
<ul>
<li>El navegador va construyendo el DOM y procesando el código en JavaScript conforme va analizando el documento HTML.</li>
<li>Estas reglas funcionan para la mayoría de ocasiones (siempre se puede usar librerías como <em>require.js</em> para casos más concretos).</li>
<li>Coloca tus referencias a <em>scripts</em> justo antes de la marca de clausura de <em>body</em> (nos evitamos usar <em>defer</em>; <em>defer</em> ejecuta en orden los <em>scripts</em> justo antes de generar <em>DOMContentLoaded</em>).</li>
</ul>
</section>
<section id="dónde-colocar-las-referencias-a-ficheros-externos-de-javascript-1" class="slide level2">
<h2>Dónde colocar las referencias a ficheros externos de JavaScript</h2>
<ul>
<li>Normalmente no es necesario preocuparse por eventos como <em>DOMContentLoaded</em> o <em>load</em>.</li>
<li>Marca tus referencias a <em>scripts</em> con <em>async</em> para que retrasen la carga de la página (el navegador las cargará y ejecutará cuando no introduzca retardos; en este caso, no se garantiza ningún orden).</li>
</ul>
<pre><code>&lt;script defer src=&quot;j1.js&quot;&gt;&lt;/script&gt;  // En HTML5 no es necesario usar type=&quot;text/javascript&quot;
&lt;script async src=&quot;j2.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;j3.js&quot;&gt;&lt;/script&gt;</code></pre>
</section>
    </div>
  </div>

  <script src="reveal.js/js/reveal.js"></script>

  <script>

      // Full list of configuration options available at:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        // Push each slide change to the browser history
        history: true,
        // Enable keyboard shortcuts for navigation
        keyboard: {37:'prev',38:'prev',39:'next',40:'next'},
        // Transition style
        transition: 'linear', // none/fade/slide/convex/concave/zoom

        // Optional reveal.js plugins
        dependencies: [
          { src: 'reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'reveal.js/plugin/zoom-js/zoom.js', async: true },
          { src: 'reveal.js/plugin/notes/notes.js', async: true }
        ]
      });
    </script>
    </body>
</html>
